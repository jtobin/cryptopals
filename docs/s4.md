### Set 4

#### 4.25

If we can control the offset and plaintext input, then we can ask
the oracle to encrypt a plaintext with the same length of the
ciphertext at offset 0. *Et voil√†*, there's our keystream, which we
can just xor with the original ciphertext in order to decrypt it.
Cryptopals.Stream.Attacks.rawrCtrAttack implements such an "attack":

    rawrCtrAttack :: IO BS.ByteString
    rawrCtrAttack = do
      cip <- rawrCtrOracle (maxBound :: Int) mempty
      let l = BS.length cip
          p = BS.replicate l 65

      new <- rawrCtrOracle 0 p
      let ks = new `CU.fixedXor` p

      pure $ ks `CU.fixedXor` cip

which gives the expected plaintext:

    > fmap (BS.take 33) rawrCtrAttack
    "I'm back and I'm ringin' the bell"

#### 4.26

After making the necessary adjustments, we can generate an analogous
ciphertext via:

    > -- Cryptopals.Stream.Attacks.bfcEncrypter
    > let cip = bfcEncrypter "AAAAA!admin!true"

Encoded as hex, this one looks like:

    911197ace68288173aeea79803ba30ff comment1=cooking
    7a45f6350fefac4ff9b4f1277500e130 %20MCs;userdata=
    843d67e24f8af8305928b16352b943e9 AAAAA!admin!true
    39e33d0551e309a752c2bb658a8ba9ee ;comment=%20like
    dda6c8de9da59acc48f4d83f0d63fb8b %20a%20pound%20o
    4969b8aac52e78b701c8da0f253efe59 fbacon__________

Here we want to target the desired bytes themselves, not the bytes in
a previous block as was done for the attack on CBC mode. Since we know
the ciphertext and plaintext byte values, we can trivially recover the
keystream at those bytes (i.e. at indices 37 and 43). Then it's just a
matter of replacing the ciphertext bytes by the keystream bytes XOR'd by
the desired plaintext:

    > -- Cryptopals.Stream.Attacks.bfcEncrypter
    > let cip = bfcEncrypter "AAAAA!admin!true"
    > :{
    ghci| let munge cip = loop 0 mempty cip where
    ghci|       p = fi (C.ord '!')
    ghci|       s = fi (C.ord ';')
    ghci|       e = fi (C.ord '=')
    ghci|       loop j acc !bs = case BS.uncons bs of
    ghci|         Nothing -> acc
    ghci|         Just (b, etc)
    ghci|           | j == 37 -> let c = BS.index cip j
    ghci|                            k = c `B.xor` p
    ghci|                            vil = k `B.xor` s
    ghci|                            nex = BS.snoc acc vil
    ghci|                        in  loop (succ j) nex etc
    ghci|           | j == 43 -> let c = BS.index cip j
    ghci|                            k = c `B.xor` p
    ghci|                            vil = k `B.xor` e
    ghci|                            nex = BS.snoc acc vil
    ghci|                        in  loop (succ j) nex etc
    ghci|           | otherwise -> loop (succ j) (BS.snoc acc b) etc
    ghci| :}
    > let munged = munge cip
    > bfcChecker cip
    False
    > bfcChecker munged
    True

#### 4.27


