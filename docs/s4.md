### Set 4

#### 4.25

If we can control the offset and plaintext input, then we can ask
the oracle to encrypt a plaintext with the same length of the
ciphertext at offset 0. *Et voil√†*, there's our keystream, which we
can just xor with the original ciphertext in order to decrypt it.
Cryptopals.Stream.Attacks.rawrCtrAttack implements such an "attack":

    rawrCtrAttack :: IO BS.ByteString
    rawrCtrAttack = do
      cip <- rawrCtrOracle (maxBound :: Int) mempty
      let l = BS.length cip
          p = BS.replicate l 65

      new <- rawrCtrOracle 0 p
      let ks = new `CU.fixedXor` p

      pure $ ks `CU.fixedXor` cip

which gives the expected plaintext:

    > fmap (BS.take 33) rawrCtrAttack
    "I'm back and I'm ringin' the bell"

#### 4.26

After making the necessary adjustments, we can generate an analogous
ciphertext via:

    > -- Cryptopals.Stream.Attacks.bfcEncrypter
    > let cip = bfcEncrypter "AAAAA!admin!true"

Encoded as hex, this one looks like:

    911197ace68288173aeea79803ba30ff comment1=cooking
    7a45f6350fefac4ff9b4f1277500e130 %20MCs;userdata=
    843d67e24f8af8305928b16352b943e9 AAAAA!admin!true
    39e33d0551e309a752c2bb658a8ba9ee ;comment=%20like
    dda6c8de9da59acc48f4d83f0d63fb8b %20a%20pound%20o
    4969b8aac52e78b701c8da0f253efe59 fbacon__________

Here we want to target the desired bytes themselves, not the bytes in
a previous block as was done for the attack on CBC mode. Since we know
the ciphertext and plaintext byte values, we can trivially recover the
keystream at those bytes (i.e. at indices 37 and 43). Then it's just a
matter of replacing the ciphertext bytes by the keystream bytes XOR'd by
the desired plaintext:

    > -- Cryptopals.Stream.Attacks.bfcEncrypter
    > let cip = bfcEncrypter "AAAAA!admin!true"
    > :{
    ghci| let munge cip = loop 0 mempty cip where
    ghci|       p = fi (C.ord '!')
    ghci|       s = fi (C.ord ';')
    ghci|       e = fi (C.ord '=')
    ghci|       loop j acc !bs = case BS.uncons bs of
    ghci|         Nothing -> acc
    ghci|         Just (b, etc)
    ghci|           | j == 37 -> let c = BS.index cip j
    ghci|                            k = c `B.xor` p
    ghci|                            vil = k `B.xor` s
    ghci|                            nex = BS.snoc acc vil
    ghci|                        in  loop (succ j) nex etc
    ghci|           | j == 43 -> let c = BS.index cip j
    ghci|                            k = c `B.xor` p
    ghci|                            vil = k `B.xor` e
    ghci|                            nex = BS.snoc acc vil
    ghci|                        in  loop (succ j) nex etc
    ghci|           | otherwise -> loop (succ j) (BS.snoc acc b) etc
    ghci| :}
    > let munged = munge cip
    > bfcChecker cip
    False
    > bfcChecker munged
    True

#### 4.27

This one works exactly as advertised. The ivl{en, de}cryptCbcAES128
functions in Cryptopals.Block.Attacks will {en, de}crypt inputs in CBC
mode using identical key and IV's, and ivlVerifier serves as the desired
oracle.

First, assembling the nasty ciphertext:

    > let b = "YELLOW SUBMARINE"
    > B16.encodeBase16 consistentKey
    "d18a7e96a50f45cb9b928e502c2b310d"
    > let cip = ivlEncryptCbcAES128 consistentKey (b <> b <> b)
    > let cs = CU.chunks 16 cip
    > let mcip = cs !! 0 <> BS.replicate 16 0 <> cs !! 0

And now recovering the key:

    > let Left mpay = ivlVerifier mcip
    > let ps = CU.chunks 16 mpay
    > B16.encodeBase16 $ (ps !! 0) `CU.fixedXor` (ps !! 2)
    "d18a7e96a50f45cb9b928e502c2b310d"

As for how this works: refer back to the omnipresent CBC-mode decryption
scheme from 2.16 (here modified):

    for ciphertext                    c = (c_1, c_2, c_3)
        block decryption w/key k      dec_k
        xor operator                  +

    let p_1 = dec_k(c_1) + k
        p_2 = dec_k(c_2) + c_1
        p_3 = dec_k(c_3) + c_2

    in  plaintext                     p = (p_1, p_2, p_3)

So if we provide the modified `c = (c_1, 0, c_1)`, decryption will give us:

    p_1' = dec_k(c_1) + k
    p_2' = dec_k(0) + c_1
    p_3' = dec_k(c_1) + 0

such that, trivially:

    p_1' + p_3' = dec_k(c_1) + k + dec_k(c_1) + 0
                = k.

#### 4.28

Using the SHA1 implementation from the 'sha' package under the hood,
Cryptopals.MAC.sha1mac implements the desired MAC (i.e. message
authentication code):

    > sha1mac "YELLOW SUBMARINE" "question 4.28"
    "45b5bb1ab02988df4609ff1227c90fe997236719"

#### 4.29


