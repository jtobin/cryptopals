#### 5.33

The basic Diffie-Hellman algorithm for key exchange between Alice and
Bob goes as follows. Alice and Bob agree on a cyclic group of some
particular order to use. They each randomly and independently pick some
number of times to perform the group operation (which must be less than
the order of the group) and perform the group operation on the generator
that number of times, publishing their results. For generator g, Alice's
number x, and Bob's number y: Alice publishes g ^ x, and Bob publishes g
^ y.

Each then performs his or her own secret number of additional group
operations on the other's public result, establishing the key g ^ xy.
Since the discrete logarithm problem is hard, an eavesdropper can't (for
an appropriate group) determine how many times either has performed the
individual group operations, even given g; he can only naÃ¯vely calculate
g ^ (x + y).

For the initial illustration here we're using a decidedly insecure
group, i.e. the multiplicative group of 16-bit words modulo 37:

    > gen <- MWC.create
    > let p = 37
    > let g = 5
    > a <- fmap (`mod` p) (MWC.uniform gen) :: IO Word16
    > b <- fmap (`mod` p) (MWC.uniform gen) :: IO Word16
    > let bigA = g ^ a `mod` p
    > let bigB = g ^ b `mod` p
    > let s = bigB ^ a `mod` p
    > let t = bigA ^ b `mod` p
    > s == t
    True
    > let k = S.sha1 . BP.runPut $ BP.putWord16be s
    > k
    ace6f761db204030c1a65c0930bd01fd55ecc429

For the big guns, we can pull out GHC's Natural type, for which
mwc-random (our preferred random library) can generate something in a
range. First a modular exponentiation routine:

    -- modified from https://gist.github.com/trevordixon/6788535
    modexp :: Natural -> Natural -> Natural -> Natural
    modexp b e m
      | e == 0    = 1
      | otherwise =
          let t = if B.testBit e 0 then b `mod` m else 1
          in  t * modexp ((b * b) `mod` m) (B.shiftR e 1) m `mod` m

and given that (and appropriate p, g), the key exchange:

    > gen <- MWC.create
    > a <- fmap (`mod` p) (MWC.uniformRM (0, p - 1) gen)
    > b <- fmap (`mod` p) (MWC.uniformRM (0, p - 1) gen)
    > let bigA = modexp g a p
    > let bigB = modexp g b p
    > let s = modexp bigB a p
    > let t = modexp bigA b p
    > s == t
    True

Our SHA1 function needs a bytestring to operate on, so to hash the
Natural key we need a quick serialization routine from Naturals
to ByteString. I happened to write one of these a few years ago
for [urbit-hob](http://git.jtobin.io/urbit-hob); it serializes in
little-endian format, and here we'll use a lazy bytestring:

    unroll :: Natural -> BL.ByteString
    unroll nat = case nat of
        0 -> BL.singleton 0
        _ -> BL.pack (L.unfoldr step nat)
      where
        step 0 = Nothing
        step i = Just (fromIntegral i, i `B.shiftR` 8)

so we can get a key via:

    > let k = S.sha1 $ unroll s
    > k
    6a86b02347be741dfb6f876819022ae1d7adda18

